Dump of assembler code for function phase_1:
   0x0000000000400ee0 <+0>:     sub    $0x8,%rsp                        //rsp - 8
   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi                   //rsi 第二个参数
   0x0000000000400ee9 <+9>:     callq  0x401338 <strings_not_equal>     
   0x0000000000400eee <+14>:    test   %eax,%eax
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:    callq  0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
   0x0000000000400efb <+27>:    retq   
End of assembler dump.

Dump of assembler code for function phase_2:
   0x0000000000400efc <+0>:     push   %rbp                             //callee saved
   0x0000000000400efd <+1>:     push   %rbx                             //callee saved
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi
   0x0000000000400f05 <+9>:     callq  0x40145c <read_six_numbers>      //rdi string rsi rsp
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)                      //rsp中的内容等于 0x1继续
   0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    callq  0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax                  // eax = *(%rsp) 
   0x0000000000400f1a <+30>:    add    %eax,%eax                        // double
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)                      // cmp *(%rsp + 4)  1 和  第二个序列比
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    callq  0x40143a <explode_bomb>          
   0x0000000000400f25 <+41>:    add    $0x4,%rbx                        // rbx = %rsp + 8
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx                        // 是否加到24了
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx                   // rbx = %rsp + 4 栈指针 + 4
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp                  // rbp = %rsp + 24 栈指针 + 24
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    retq   
End of assembler dump.

Dump of assembler code for function phase_3:
   0x0000000000400f43 <+0>:     sub    $0x18,%rsp
   0x0000000000400f47 <+4>:     lea    0xc(%rsp),%rcx                   //参数4     %rsp + 12
   0x0000000000400f4c <+9>:     lea    0x8(%rsp),%rdx                   //参数3     %rsp + 8
   0x0000000000400f51 <+14>:    mov    $0x4025cf,%esi                   //0x4025cf = "%d %d"
   0x0000000000400f56 <+19>:    mov    $0x0,%eax
   0x0000000000400f5b <+24>:    callq  0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000400f60 <+29>:    cmp    $0x1,%eax                        //小于等于1则爆炸
   0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>
   0x0000000000400f65 <+34>:    callq  0x40143a <explode_bomb>
   0x0000000000400f6a <+39>:    cmpl   $0x7,0x8(%rsp)                   //参数3 无符号大于> 0-7 之间满足
   0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106>           //explode_bomb
   0x0000000000400f71 <+46>:    mov    0x8(%rsp),%eax
   0x0000000000400f75 <+50>:    jmpq   *0x402470(,%rax,8)               //0x00400f7c - 0x00400fa6 
   0x0000000000400f7c <+57>:    mov    $0xcf,%eax                       //0 0xcf    207
   0x0000000000400f81 <+62>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f83 <+64>:    mov    $0x2c3,%eax                      //2 0x2c3   707
   0x0000000000400f88 <+69>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:    mov    $0x100,%eax                      //3 0x100   256
   0x0000000000400f8f <+76>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:    mov    $0x185,%eax                      //4 0x185   389
   0x0000000000400f96 <+83>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:    mov    $0xce,%eax                       //5 0xce    206
   0x0000000000400f9d <+90>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:    mov    $0x2aa,%eax                      //6 0x2aa   682
   0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:    mov    $0x147,%eax                      //7 0x147   327
   0x0000000000400fab <+104>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:   callq  0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:   mov    $0x0,%eax
   0x0000000000400fb7 <+116>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:   mov    $0x137,%eax                      //1 0x137   311
   0x0000000000400fbe <+123>:   cmp    0xc(%rsp),%eax                   //比较参数4 和 eax 不相等则爆炸
   0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:   callq  0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:   add    $0x18,%rsp
   0x0000000000400fcd <+138>:   retq   
End of assembler dump.

Dump of assembler code for function phase_4:
   0x000000000040100c <+0>:     sub    $0x18,%rsp
   0x0000000000401010 <+4>:     lea    0xc(%rsp),%rcx                   //参数4     %rsp + 12
   0x0000000000401015 <+9>:     lea    0x8(%rsp),%rdx                   //参数3     %rsp + 8
   0x000000000040101a <+14>:    mov    $0x4025cf,%esi                   //0x4025cf = "%d %d" ??
   0x000000000040101f <+19>:    mov    $0x0,%eax
   0x0000000000401024 <+24>:    callq  0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000401029 <+29>:    cmp    $0x2,%eax                        //不等于2则爆炸
   0x000000000040102c <+32>:    jne    0x401035 <phase_4+41>
   0x000000000040102e <+34>:    cmpl   $0xe,0x8(%rsp)                   //取出%rsp + 8  第一个输入 比较双字  无符号 小于或相等  [0-14]
   0x0000000000401033 <+39>:    jbe    0x40103a <phase_4+46>
   0x0000000000401035 <+41>:    callq  0x40143a <explode_bomb>
   0x000000000040103a <+46>:    mov    $0xe,%edx                        //%edx = 14
   0x000000000040103f <+51>:    mov    $0x0,%esi                        //func4 参数2 = 0
   0x0000000000401044 <+56>:    mov    0x8(%rsp),%edi                   //取出%rsp + 8  func4 参数1 = 第一个输入
   0x0000000000401048 <+60>:    callq  0x400fce <func4>
   0x000000000040104d <+65>:    test   %eax,%eax                        //返回不为0则爆炸
   0x000000000040104f <+67>:    jne    0x401058 <phase_4+76>
   0x0000000000401051 <+69>:    cmpl   $0x0,0xc(%rsp)                   //取出%rsp + 12  第二个输入 第二个输入为0
   0x0000000000401056 <+74>:    je     0x40105d <phase_4+81>
   0x0000000000401058 <+76>:    callq  0x40143a <explode_bomb>
   0x000000000040105d <+81>:    add    $0x18,%rsp
   0x0000000000401061 <+85>:    retq   
End of assembler dump.


Dump of assembler code for function phase_5:
   0x0000000000401062 <+0>:     push   %rbx
   0x0000000000401063 <+1>:     sub    $0x20,%rsp
   0x0000000000401067 <+5>:     mov    %rdi,%rbx                        //输入string地址
   0x000000000040106a <+8>:     mov    %fs:0x28,%rax
   0x0000000000401073 <+17>:    mov    %rax,0x18(%rsp)                  //canary
   0x0000000000401078 <+22>:    xor    %eax,%eax                        //清零
   0x000000000040107a <+24>:    callq  0x40131b <string_length>         
   0x000000000040107f <+29>:    cmp    $0x6,%eax                        //长度为6
   0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:    callq  0x40143a <explode_bomb>          //不为6就炸了
   0x0000000000401089 <+39>:    jmp    0x4010d2 <phase_5+112>
   0x000000000040108b <+41>:    movzbl (%rbx,%rax,1),%ecx               //零扩展字节到双字  (%rbx) -> %ecx 一个char
   0x000000000040108f <+45>:    mov    %cl,(%rsp)                       //%rcx的低字节
   0x0000000000401092 <+48>:    mov    (%rsp),%rdx
   0x0000000000401096 <+52>:    and    $0xf,%edx                        //%edx 保留后四位
   0x0000000000401099 <+55>:    movzbl 0x4024b0(%rdx),%edx
   0x00000000004010a0 <+62>:    mov    %dl,0x10(%rsp,%rax,1)            //%rdx的低字节 >> 上一个char的后16位
   0x00000000004010a4 <+66>:    add    $0x1,%rax
   0x00000000004010a8 <+70>:    cmp    $0x6,%rax
   0x00000000004010ac <+74>:    jne    0x40108b <phase_5+41>
   0x00000000004010ae <+76>:    movb   $0x0,0x16(%rsp)                  //在0x10(%rsp) 处存入了一共 string
   0x00000000004010b3 <+81>:    mov    $0x40245e,%esi                   //参数二
   0x00000000004010b8 <+86>:    lea    0x10(%rsp),%rdi                  //参数一
   0x00000000004010bd <+91>:    callq  0x401338 <strings_not_equal>
   0x00000000004010c2 <+96>:    test   %eax,%eax
   0x00000000004010c4 <+98>:    je     0x4010d9 <phase_5+119>           //不相等则爆炸
   0x00000000004010c6 <+100>:   callq  0x40143a <explode_bomb>
   0x00000000004010cb <+105>:   nopl   0x0(%rax,%rax,1)
   0x00000000004010d0 <+110>:   jmp    0x4010d9 <phase_5+119>
   0x00000000004010d2 <+112>:   mov    $0x0,%eax                        //%rax清0
   0x00000000004010d7 <+117>:   jmp    0x40108b <phase_5+41>
   0x00000000004010d9 <+119>:   mov    0x18(%rsp),%rax
   0x00000000004010de <+124>:   xor    %fs:0x28,%rax
   0x00000000004010e7 <+133>:   je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:   callq  0x400b30 <__stack_chk_fail@plt>
   0x00000000004010ee <+140>:   add    $0x20,%rsp
   0x00000000004010f2 <+144>:   pop    %rbx
   0x00000000004010f3 <+145>:   retq   
End of assembler dump.

//   $1 = 0x40245e "flyers"
//                  9 15 14 5 6 7
//                  9 f  e  5 6 7 
//                  I O  N  E F G
//   $2 = 0x4024b0 m a d u i e r s n f o  t  v  b  y  l  S  o
//                 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17


Dump of assembler code for function phase_6:
   0x00000000004010f4 <+0>:     push   %r14
   0x00000000004010f6 <+2>:     push   %r13
   0x00000000004010f8 <+4>:     push   %r12
   0x00000000004010fa <+6>:     push   %rbp
   0x00000000004010fb <+7>:     push   %rbx
   0x00000000004010fc <+8>:     sub    $0x50,%rsp
   0x0000000000401100 <+12>:    mov    %rsp,%r13      
   0x0000000000401103 <+15>:    mov    %rsp,%rsi                           //rsp为参数
   0x0000000000401106 <+18>:    callq  0x40145c <read_six_numbers>    
   0x000000000040110b <+23>:    mov    %rsp,%r14                           //从 rsp 到 rsp + 24 处为6个int   
   0x000000000040110e <+26>:    mov    $0x0,%r12d                          //%r12的低32位
       
   //每个数都和其后的数不相同
   0x0000000000401114 <+32>:    mov    %r13,%rbp                           //%rbp = %rsp 
   0x0000000000401117 <+35>:    mov    0x0(%r13),%eax                      //第一个数字
   0x000000000040111b <+39>:    sub    $0x1,%eax                           //%eax - 1
   0x000000000040111e <+42>:    cmp    $0x5,%eax
   0x0000000000401121 <+45>:    jbe    0x401128 <phase_6+52>               //1-6  
   0x0000000000401123 <+47>:    callq  0x40143a <explode_bomb>
   0x0000000000401128 <+52>:    add    $0x1,%r12d                          //%r12d  0 - 6 
   0x000000000040112c <+56>:    cmp    $0x6,%r12d
   0x0000000000401130 <+60>:    je     0x401153 <phase_6+95>
   0x0000000000401132 <+62>:    mov    %r12d,%ebx                          //%ebx = 1-6
   //验证此数和其后的数字是否相同
   0x0000000000401135 <+65>:    movslq %ebx,%rax                           //符号扩展的双字到四字
   0x0000000000401138 <+68>:    mov    (%rsp,%rax,4),%eax                  //(%rsp + &r12d * 4)
   0x000000000040113b <+71>:    cmp    %eax,0x0(%rbp)                      //不相等 相等则爆炸     后5个数不能和第一个数相等
   0x000000000040113e <+74>:    jne    0x401145 <phase_6+81>
   0x0000000000401140 <+76>:    callq  0x40143a <explode_bomb>
   0x0000000000401145 <+81>:    add    $0x1,%ebx                           //%r12d++
   0x0000000000401148 <+84>:    cmp    $0x5,%ebx
   0x000000000040114b <+87>:    jle    0x401135 <phase_6+65>               //小于等于5继续

   0x000000000040114d <+89>:    add    $0x4,%r13                           //%r13 = %rsp + 0x4
   0x0000000000401151 <+93>:    jmp    0x401114 <phase_6+32>
   
   //将读入的6个数字换为 7 - i
   0x0000000000401153 <+95>:    lea    0x18(%rsp),%rsi                     //rsp + 24 
   0x0000000000401158 <+100>:   mov    %r14,%rax                           //rsp
   0x000000000040115b <+103>:   mov    $0x7,%ecx
   0x0000000000401160 <+108>:   mov    %ecx,%edx                           //ecx = edx = 7
   0x0000000000401162 <+110>:   sub    (%rax),%edx                         //7 - 第i个数字 
   0x0000000000401164 <+112>:   mov    %edx,(%rax)                         //(rsp + 4i) = 7 - 第i个数字 
   0x0000000000401166 <+114>:   add    $0x4,%rax
   0x000000000040116a <+118>:   cmp    %rsi,%rax                           //6个int的空间用完
   0x000000000040116d <+121>:   jne    0x401160 <phase_6+108>

   //利用转换后的6个数字取出 内存 0x6032d0 多次间接引用的指针存在 %rsp + 32 到 %rsp + 80
   0x000000000040116f <+123>:   mov    $0x0,%esi                           //%esi = 0
   0x0000000000401174 <+128>:   jmp    0x401197 <phase_6+163>

   0x0000000000401176 <+130>:   mov    0x8(%rdx),%rdx                      //0x6032d0 + 0x8
   0x000000000040117a <+134>:   add    $0x1,%eax                           //%eax ++
   0x000000000040117d <+137>:   cmp    %ecx,%eax                           //处理后的数字
   0x000000000040117f <+139>:   jne    0x401176 <phase_6+130>              //最终%ecx = %eax %rdx中内容为对 0x6032d0 多次间接引用后的值
   0x0000000000401181 <+141>:   jmp    0x401188 <phase_6+148>
   0x0000000000401183 <+143>:   mov    $0x6032d0,%edx                      (1 1) (2 2) (3 3) (4 4) (5 5) (6 6)
   0x0000000000401188 <+148>:   mov    %rdx,0x20(%rsp,%rsi,2)              //存入(%rsp + 2 * %rsi + 32) 最大为0x50
   0x000000000040118d <+153>:   add    $0x4,%rsi                           //%rsi += 0x4  
   0x0000000000401191 <+157>:   cmp    $0x18,%rsi                          //24
   0x0000000000401195 <+161>:   je     0x4011ab <phase_6+183>              //跳转183

   0x0000000000401197 <+163>:   mov    (%rsp,%rsi,1),%ecx                  // %ecx = (%rsp + %rsi)
   0x000000000040119a <+166>:   cmp    $0x1,%ecx                           // 7 - array[i] 之后的数字 小于等于1
   0x000000000040119d <+169>:   jle    0x401183 <phase_6+143>
   0x000000000040119f <+171>:   mov    $0x1,%eax                           //%eax = 0x1
   0x00000000004011a4 <+176>:   mov    $0x6032d0,%edx                      //%edx = 0x6032d0
   0x00000000004011a9 <+181>:   jmp    0x401176 <phase_6+130>

   0x00000000004011ab <+183>:   mov    0x20(%rsp),%rbx                     // %rsp + 32 上面移入的第一个地址 %rbx 为第一个指针
   0x00000000004011b0 <+188>:   lea    0x28(%rsp),%rax                     //%rax 第二个指针的地址
   0x00000000004011b5 <+193>:   lea    0x50(%rsp),%rsi                     //停止标志?
   0x00000000004011ba <+198>:   mov    %rbx,%rcx

   0x00000000004011bd <+201>:   mov    (%rax),%rdx                         //%rdx为第二个指针 此后为第三个指针 第四个.....
   0x00000000004011c0 <+204>:   mov    %rdx,0x8(%rcx)                      //指针1 + 8 的位置存放  指针2    指针2 + 8 的位置存放  指针3
   0x00000000004011c4 <+208>:   add    $0x8,%rax                           //%rax += 0x8
   0x00000000004011c8 <+212>:   cmp    %rsi,%rax                           //是否到达0x50
   0x00000000004011cb <+215>:   je     0x4011d2 <phase_6+222>
   0x00000000004011cd <+217>:   mov    %rdx,%rcx                           //%rcx为第二个指针 第三个指针
   0x00000000004011d0 <+220>:   jmp    0x4011bd <phase_6+201>
   0x00000000004011d2 <+222>:   movq   $0x0,0x8(%rdx)                      //指针6 + 8 = 0x0
   0x00000000004011da <+230>:   mov    $0x5,%ebp
   0x00000000004011df <+235>:   mov    0x8(%rbx),%rax                      //%rax = 指针2
   0x00000000004011e3 <+239>:   mov    (%rax),%eax                         //eax为指针2的值
   0x00000000004011e5 <+241>:   cmp    %eax,(%rbx)                         //和指针1的值比较
   0x00000000004011e7 <+243>:   jge    0x4011ee <phase_6+250>              //第一个要大于第二个
   0x00000000004011e9 <+245>:   callq  0x40143a <explode_bomb>
   0x00000000004011ee <+250>:   mov    0x8(%rbx),%rbx                      //第二个大于第三个
   0x00000000004011f2 <+254>:   sub    $0x1,%ebp                           //指针指示的数按照降序排列
   0x00000000004011f5 <+257>:   jne    0x4011df <phase_6+235>
   
   0x00000000004011f7 <+259>:   add    $0x50,%rsp
   0x00000000004011fb <+263>:   pop    %rbx
   0x00000000004011fc <+264>:   pop    %rbp
   0x00000000004011fd <+265>:   pop    %r12
   0x00000000004011ff <+267>:   pop    %r13
   0x0000000000401201 <+269>:   pop    %r14
   0x0000000000401203 <+271>:   retq   
End of assembler dump.

//x/24wx 0x6032d0

0x6032d0 <node1>:       0x0000014c      0x00000001      0x006032e0      0x00000000     332
0x6032e0 <node2>:       0x000000a8      0x00000002      0x006032f0      0x00000000     168
0x6032f0 <node3>:       0x0000039c      0x00000003      0x00603300      0x00000000     924  
0x603300 <node4>:       0x000002b3      0x00000004      0x00603310      0x00000000     691
0x603310 <node5>:       0x000001dd      0x00000005      0x00603320      0x00000000     477
0x603320 <node6>:       0x000001bb      0x00000006      0x00000000      0x00000000     443

(1 node 1) (2 node 2) (3 node3) (4 node4) (5 node5) (6 node6)
3 4 5 6 1 2
4 3 2 1 6 5